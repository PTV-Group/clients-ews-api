/*
 * EWS Road Distance
 * With the EWS Road Distance service you can query pre-calculated distances and additional information for relations between reference locations in Europe.
 *
 * The version of the OpenAPI document: 1.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.ptvgroup.developer.client.ews.api;

import com.ptvgroup.developer.client.ews.ApiClient;
import com.ptvgroup.developer.client.ews.ApiException;
import com.ptvgroup.developer.client.ews.ApiResponse;
import com.ptvgroup.developer.client.ews.Pair;

import com.ptvgroup.developer.client.ews.model.DataVersionType;
import com.ptvgroup.developer.client.ews.model.ErrorResponse;
import com.ptvgroup.developer.client.ews.model.LocationType;
import com.ptvgroup.developer.client.ews.model.RegionType;
import com.ptvgroup.developer.client.ews.model.RequestLocation;
import com.ptvgroup.developer.client.ews.model.ResultsType;
import com.ptvgroup.developer.client.ews.model.RoadDistanceResponse;
import com.ptvgroup.developer.client.ews.model.SuggestionsResponse;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-03-07T15:05:32.711837Z[Etc/UTC]")
public class RoadDistancesApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public RoadDistancesApi() {
    this(new ApiClient());
  }

  public RoadDistancesApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * 
   * Gets the truck distance and additional information for a relation between two locations.
   * @param start The start of the relation. (optional)
   * @param destination The destination of the relation. (optional)
   * @param region  (optional, default to BEST_QUALITY)
   * @param dataVersion  (optional, default to LATEST)
   * @param results Comma-separated list that defines which results besides the distance will be returned. * &#x60;COORDINATES&#x60;     Response includes latitude and longitude of the reference locations of start and destination. * &#x60;TOLL_DISTANCE&#x60;     Response includes the distance of toll roads of the relation. (optional
   * @return RoadDistanceResponse
   * @throws ApiException if fails to make API call
   */
  public RoadDistanceResponse getRelation(RequestLocation start, RequestLocation destination, RegionType region, DataVersionType dataVersion, List<ResultsType> results) throws ApiException {
    ApiResponse<RoadDistanceResponse> localVarResponse = getRelationWithHttpInfo(start, destination, region, dataVersion, results);
    return localVarResponse.getData();
  }

  /**
   * 
   * Gets the truck distance and additional information for a relation between two locations.
   * @param start The start of the relation. (optional)
   * @param destination The destination of the relation. (optional)
   * @param region  (optional, default to BEST_QUALITY)
   * @param dataVersion  (optional, default to LATEST)
   * @param results Comma-separated list that defines which results besides the distance will be returned. * &#x60;COORDINATES&#x60;     Response includes latitude and longitude of the reference locations of start and destination. * &#x60;TOLL_DISTANCE&#x60;     Response includes the distance of toll roads of the relation. (optional
   * @return ApiResponse&lt;RoadDistanceResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<RoadDistanceResponse> getRelationWithHttpInfo(RequestLocation start, RequestLocation destination, RegionType region, DataVersionType dataVersion, List<ResultsType> results) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getRelationRequestBuilder(start, destination, region, dataVersion, results);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getRelation", localVarResponse);
        }
        return new ApiResponse<RoadDistanceResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RoadDistanceResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getRelationRequestBuilder(RequestLocation start, RequestLocation destination, RegionType region, DataVersionType dataVersion, List<ResultsType> results) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/relations";

    List<Pair> localVarQueryParams = new ArrayList<>();
    if (start != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("start[country]", start.getCountry()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("start[postalCode]", start.getPostalCode()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("start[locality]", start.getLocality()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("start[type]", start.getType()));
    }
    if (destination != null) {
      localVarQueryParams.addAll(ApiClient.parameterToPairs("destination[country]", destination.getCountry()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("destination[postalCode]", destination.getPostalCode()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("destination[locality]", destination.getLocality()));
      localVarQueryParams.addAll(ApiClient.parameterToPairs("destination[type]", destination.getType()));
    }
    localVarQueryParams.addAll(ApiClient.parameterToPairs("region", region));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("dataVersion", dataVersion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "results", results));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Gets suggestions for a location. Provide at least two characters in **postalCode** or **locality** to obtain results.
   * @param country The country represented by its code according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
   * @param postalCode The postal code or its initial characters. (optional)
   * @param locality The name or initial characters of the city or district in the language spoken in that country or region, always transliterated to Latin. The input will first be matched to city names and then to subdistrict names. (optional)
   * @param region  (optional, default to BEST_QUALITY)
   * @param dataVersion  (optional, default to LATEST)
   * @param type  (optional, default to CITY)
   * @param limit  (optional, default to 10)
   * @return SuggestionsResponse
   * @throws ApiException if fails to make API call
   */
  public SuggestionsResponse getSuggestions(String country, String postalCode, String locality, RegionType region, DataVersionType dataVersion, LocationType type, Integer limit) throws ApiException {
    ApiResponse<SuggestionsResponse> localVarResponse = getSuggestionsWithHttpInfo(country, postalCode, locality, region, dataVersion, type, limit);
    return localVarResponse.getData();
  }

  /**
   * 
   * Gets suggestions for a location. Provide at least two characters in **postalCode** or **locality** to obtain results.
   * @param country The country represented by its code according to [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
   * @param postalCode The postal code or its initial characters. (optional)
   * @param locality The name or initial characters of the city or district in the language spoken in that country or region, always transliterated to Latin. The input will first be matched to city names and then to subdistrict names. (optional)
   * @param region  (optional, default to BEST_QUALITY)
   * @param dataVersion  (optional, default to LATEST)
   * @param type  (optional, default to CITY)
   * @param limit  (optional, default to 10)
   * @return ApiResponse&lt;SuggestionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SuggestionsResponse> getSuggestionsWithHttpInfo(String country, String postalCode, String locality, RegionType region, DataVersionType dataVersion, LocationType type, Integer limit) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getSuggestionsRequestBuilder(country, postalCode, locality, region, dataVersion, type, limit);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getSuggestions", localVarResponse);
        }
        return new ApiResponse<SuggestionsResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<SuggestionsResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getSuggestionsRequestBuilder(String country, String postalCode, String locality, RegionType region, DataVersionType dataVersion, LocationType type, Integer limit) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/suggestions";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("country", country));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("postalCode", postalCode));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("locality", locality));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("region", region));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("dataVersion", dataVersion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("type", type));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
